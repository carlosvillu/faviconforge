# Task Planning Workflow

## CRITICAL: Planning vs Implementation

**Planning and implementation are SEPARATE phases. NEVER mix them.**

When the user asks to "plan" or "planificar" a task:
1. The agent MUST ONLY create the planning file in `features/`
2. The agent MUST NOT start implementing (no code changes, no migrations, no test files)
3. The agent MUST NOT use TodoWrite to track implementation tasks
4. After creating the planning file, the agent MUST STOP and wait for explicit user approval

**The planning phase ends when the file is created in `features/`. Full stop.**

Implementation only begins when the user explicitly says: "implementa", "implement", "ejecuta", "execute", or similar.

---

## Information Gathering Phase

Before creating any planning document:

- ASK all necessary questions to fully understand the task
- Continue asking clarifying questions as many times as needed until you have complete clarity
- Do NOT start writing the planning file until you have gathered ALL the information required
- Questions may cover: scope, edge cases, UI/UX expectations, business rules, integration details, etc.
- **If the task involves creating tests:** MUST read `docs/TESTING.md` before planning to understand project conventions, existing fixtures, and patterns
- **If the task involves creating server-side services (`app/services/*.server.ts`):** MUST read `docs/TESTING.md` section "Testing Services via E2E" to understand how to test services via test-only endpoints
- **If the task involves creating client-side services (`app/services/*.ts` without `.server`):** MUST read `docs/TESTING.md` section "Testing Client-Side Services" to understand how to test with Vitest unit tests

## Planning File Structure

When the user requests planning for a task from `PLANNING.md`, create a detailed planning file in the `features/` directory:

**File naming:** `features/FEATURE_[TASK_CODE]_[NOMBRE_FEATURE].md`

**Purpose:** This file is generated by a planning model (Opus 4.5) to provide clear, detailed guidance so an implementation model (Sonnet 4.5) can execute the changes without ambiguity or creating unnecessary code.

### Required Sections

#### 1. Natural Language Description

- What we expect to achieve with this task
- Current state of the project (how it starts)
- Expected end state (how it should finish)

#### 2. Technical Description

- High-level technical approach
- Architecture decisions
- Dependencies or integrations involved
- **Do NOT include file-by-file or code-level details here**

#### 2.1. Architecture Gate (REQUIRED)

Every planning file MUST include this section and satisfy ALL items:

- **Pages are puzzles:** route modules contain **no UI** or the **minimum UI** needed to compose existing components.
- **Loaders/actions are thin:** parse `request`, decide intent, call the right service(s), return data/redirect.
  - Loaders/actions must NOT implement domain rules, DB queries, or business invariants inline.
- **Business logic is not in components:**
  - Domain logic lives in **services** (`app/services/*`).
  - UI/stateful orchestration lives in **custom hooks** (`app/hooks/*`).
  - Components focus on rendering + wiring hooks.

If the task is a **move-only refactor** (no functional changes), the plan MUST also include these guardrails:

- No changes to user-visible texts or `t('...')` usage.
- No changes to markup structure or classNames (copy JSX literally when extracting components).
- No changes to existing E2E tests; tests are a contract for move-only refactors.
- Any re-organization must be done by moving code into `app/components/*`, `app/hooks/*`, `app/services/*`, or `app/lib/*` as appropriate.

In the plan, explicitly state:

- For each **route module**: which services it calls (loader/action) and which components it composes.
- For each **component**: which hooks it uses and what business logic is intentionally NOT inside it.

#### 3. Files to Change/Create

For each file:

````
### `path/to/file.ext`
**Objective:** [Natural language description of what this file should accomplish]

**Pseudocode:**
```pseudocode
// What should be implemented/changed
FUNCTION example
  INPUT: ...
  PROCESS: ...
  OUTPUT: ...
END
```

**Additional planning rules (MUST follow):**

- If the file is a **route module** (`app/routes/*.tsx`): pseudocode MUST include separate blocks for:
  - `loader` (data fetching + service calls)
  - `action` (intent parsing + service calls)
  - `component` (composition only; no business rules)
- If the file is a **service** (`app/services/*`): pseudocode MUST specify inputs/outputs and error codes; keep domain rules here.
- If the file is a **hook** (`app/hooks/*`): pseudocode MUST specify state + effects + how it orchestrates services/actions.
- If the file is a **component** (`app/components/*`): pseudocode MUST be rendering-focused and list the hooks it consumes.
````

#### 4. I18N Section (Required for UI tasks)

If the task involves UI changes, include an i18n section:

```markdown
### I18N

#### Existing keys to reuse
- `login_title` - For the page title
- `email_label` - For the email field

#### New keys to create
| Key | English | Spanish |
|-----|---------|---------|
| `new_feature_title` | My Feature | Mi Funcionalidad |
| `new_feature_desc` | Description here | Descripción aquí |
```

**Guidelines:**
- Check `app/locales/en.json` for existing keys before creating new ones
- Use semantic key names (based on meaning, not position)
- Use `snake_case` with logical prefixes (`*_title`, `*_label`, `*_error`, etc.)
- See `docs/I18N.md` for full documentation

#### 5. E2E Test Plan (or Unit Test Plan)

**For server-side features** (routes, loaders, actions, `*.server.ts` services):
- Write E2E tests in `tests/e2e/*.spec.ts`
- Use TestContainers for database isolation
- Run with `npm run test:e2e -- --retries=1`

**For client-side services** (`app/services/*.ts` without `.server`):
- Write unit tests in `tests/unit/*.test.ts`
- Use Vitest with jsdom environment
- Run with `npm run test:unit`

Each test should include:
- **Test name**
- **Preconditions**
- **Steps**
- **Expected result**

#### 6. Definition of Done (CRITICAL)

**A task is NOT complete unless ALL of the following are green:**

1. **ALL relevant tests pass:**
   - `npm run test:e2e -- --retries=1` (if task has E2E tests)
   - `npm run test:unit` (if task has unit tests)
   - **If any test fails, the task is NOT done**
2. `npm run typecheck` passes
3. `npm run lint` passes
4. All acceptance criteria from section 1 are met

**Never mark a task as complete with failing tests.**

## Example Planning File

```markdown
# PLANNING_FEATURE_UserAuthentication–001.md

## 1. Natural Language Description
Currently the app shows... After this task, users will be able to...

## 2. Technical Description
We will implement... using... The data flow will be...

## 2.1. Architecture Gate

- **Pages are puzzles:** route modules compose components, minimal UI.
- **Loaders/actions are thin:** parse `request` + call services + return.
- **Business logic is not in components:** domain logic in `app/services/*`, UI orchestration in `app/hooks/*`.

## 3. Files to Change/Create

### `app/routes/example.tsx`
**Objective:** Handle the new route for...

**Pseudocode:**
```pseudocode
COMPONENT ExamplePage
  LOAD data from API
  RENDER list of items
  ON click item -> navigate to detail
END
````

### `app/components/ExampleList.tsx`

**Objective:** Display items in a grid...

**Pseudocode:**

```pseudocode
COMPONENT ExampleList
  PROPS: items[]
  RENDER grid with items.map()
END
```

## 4. E2E Test Plan

### Test: User can view example list

- **Preconditions:** User is logged in
- **Steps:** Navigate to /example
- **Expected:** List displays with at least 3 items

### Test: User can click item to see details

- **Preconditions:** User is on /example
- **Steps:** Click first item
- **Expected:** Navigates to /example/[id] with item details

---

## Bugfix Planning

Bugfixes follow a different structure than features. The focus is on **reproducing the bug**, **understanding the root cause**, and **adding regression tests**.

**File naming:** `bugfixes/BUGFIX_[TASK_CODE]_[NOMBRE_BUG].md`

### Required Sections for Bugfix

#### 1. Bug Description (Natural Language)

##### Current Behavior (Bug)
- Describe what is happening incorrectly
- Step-by-step instructions to reproduce the bug
- Include screenshots or error messages if available

##### Expected Behavior (After Fix)
- Describe what should happen instead
- How the user experience should be after the fix

#### 2. Technical Analysis

##### Conflicting Flow
- Describe the technical flow that causes the bug
- Identify the components/functions involved
- Explain why the current implementation fails

##### Root Cause
- If **OBVIOUS**: Clearly state the root cause
- If **NOT OBVIOUS**: List the most plausible theories (max 3-4) with:
  - Theory description
  - Investigation steps to validate/discard it

#### 3. Solution Plan (Only if root cause is OBVIOUS)

For each file to modify/create:

````
### `path/to/file.ext`
**Objective:** [What needs to change to fix the bug]

**Pseudocode:**
```pseudocode
// Changes required
BEFORE: ...
AFTER: ...
```
````

**If root cause is NOT obvious:** Skip this section. The bugfix cannot proceed until investigation is complete.

#### 4. Regression Tests (E2E Only)

Bugfixes ONLY add regression tests. These tests must:
- Prove the bug no longer occurs
- Cover the exact reproduction steps described in section 1
- NOT include refactors, improvements, or unrelated changes

```markdown
### Test: [Bug description] no longer occurs
- **Preconditions:** [Setup to reproduce the bug]
- **Steps:** [Exact reproduction steps]
- **Expected:** [Correct behavior, not the bug]
```

#### 5. Lessons Learned (Optional)

If this bug revealed something important about the codebase, architecture, or patterns:
- Document the lesson in `docs/KNOWN_ISSUES.md`
- Reference the bugfix file for context

### Example Bugfix Planning File

```markdown
# BUGFIX_1.3_LoginRedirectLoop.md

## 1. Bug Description

### Current Behavior (Bug)
When a user logs in from the `/pricing` page, they get stuck in a redirect loop between `/dashboard` and `/auth/login`.

**Steps to reproduce:**
1. Go to `/pricing` (not logged in)
2. Click "Start Free Trial"
3. Complete login form
4. Observe: Page flickers between `/dashboard` and `/auth/login`

### Expected Behavior (After Fix)
After login from `/pricing`, user should land on `/dashboard` and stay there.

## 2. Technical Analysis

### Conflicting Flow
1. User clicks login → `auth.login.tsx` handles form
2. On success, `redirect("/dashboard")` is called
3. Dashboard loader checks `session` → finds it null (cookie not set yet?)
4. Dashboard redirects to `/auth/login`
5. Login page sees valid session → redirects to `/dashboard`
6. Loop continues

### Root Cause
**OBVIOUS:** The session cookie is set with `SameSite=Strict` but the redirect happens before the browser processes the Set-Cookie header.

## 3. Solution Plan

### `app/lib/auth.ts`
**Objective:** Change cookie settings to allow immediate availability after redirect

**Pseudocode:**
```pseudocode
BEFORE: cookie.sameSite = "strict"
AFTER: cookie.sameSite = "lax"
```

## 4. Regression Tests

### Test: Login from pricing page redirects to dashboard without loop
- **Preconditions:** User is not logged in, valid credentials exist
- **Steps:**
  1. Navigate to `/pricing`
  2. Click "Start Free Trial"
  3. Fill login form with valid credentials
  4. Submit form
- **Expected:** User lands on `/dashboard`, no redirect loop, page is stable

## 5. Lessons Learned

Added to `docs/KNOWN_ISSUES.md`:
- Cookie `SameSite=Strict` can cause redirect loops when setting cookies during POST-redirect-GET flows

---

## KNOWN_ISSUES.md

When a bugfix reveals an important lesson about the codebase, add it to `docs/KNOWN_ISSUES.md`.

**Structure:**
```markdown
# Known Issues & Lessons Learned

## [Category: Auth/DB/API/UI/etc.]

### [Issue Title]
**Discovered in:** BUGFIX_X.X_Name.md
**Date:** YYYY-MM-DD

**Problem:** Brief description of what went wrong

**Root Cause:** Technical explanation

**Solution:** How it was fixed

**Prevention:** How to avoid this in the future
```

This document serves as a knowledge base to prevent repeating the same mistakes.
